name: Deploy Hindsight AI with Docker Compose

on:
  push:
    branches: [ main, staging ]
  workflow_dispatch:
    inputs:
      recreate_acme_json:
        description: "Recreate acme.json for Let's Encrypt"
        required: true
        type: boolean
        default: false

jobs:
  hindsight-service-tests:
    name: Hindsight Service (pytest)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: apps/hindsight-service
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Make test script executable
        run: chmod +x run_tests.sh

      - name: Run tests
        run: ./run_tests.sh --no-cov

      - name: Query expansion evaluation summary
        run: |
          docker run --rm \
            -v "$(pwd):/app" \
            -w /app/apps/hindsight-service \
            -e DATABASE_URL=sqlite+pysqlite:///:memory: \
            -e HINDSIGHT_TEST_DB=sqlite+pysqlite:///:memory: \
            -e QUERY_EXPANSION_LLM_PROVIDER=mock \
            -e PYTHONPATH=/app \
            hindsight-service-test \
            /bin/bash -lc "uv run python scripts/run_query_expansion_evaluation.py --seed-sample-data --output /app/query-expansion-summary.json"

      - name: Upload query expansion summary
        uses: actions/upload-artifact@v4
        with:
          name: query-expansion-summary
          path: apps/hindsight-service/query-expansion-summary.json

  dashboard-tests:
    name: Dashboard (Jest)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: apps/hindsight-dashboard
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/hindsight-dashboard/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run Jest (coverage)
        run: npm run test:coverage -- --ci

  build-and-push-hindsight-service:
    needs: [hindsight-service-tests, dashboard-tests]
    runs-on: ubuntu-latest
    # Select environment based on branch so we can use env-scoped secrets
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get backend version
        id: backend-version
        run: |
          VERSION=$(cat apps/hindsight-service/pyproject.toml | grep -E "^version\s*=" | sed -E 's/version\s*=\s*"([^"]+)"$/\1/')
          echo "BACKEND_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set build timestamp
        id: build-timestamp
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "BUILD_TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

      - name: Build and push Hindsight Service Docker image
        id: build-push-service
        uses: docker/build-push-action@v5
        with:
          context: apps/hindsight-service
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/hindsight-service:${{ github.sha }}
            ${{ github.ref == 'refs/heads/main' && format('ghcr.io/{0}/hindsight-service:latest', github.repository_owner) || '' }}
            ${{ github.ref == 'refs/heads/staging' && format('ghcr.io/{0}/hindsight-service:staging-latest', github.repository_owner) || '' }}
          file: apps/hindsight-service/Dockerfile
          build-args: |
            BUILD_SHA=${{ github.sha }}
            BUILD_TIMESTAMP=${{ env.BUILD_TIMESTAMP }}
            IMAGE_TAG=ghcr.io/${{ github.repository_owner }}/hindsight-service:${{ github.sha }}
            VERSION=${{ env.BACKEND_VERSION }}

  build-and-push-hindsight-dashboard:
    needs: [hindsight-service-tests, dashboard-tests]
    runs-on: ubuntu-latest
    # Select environment based on branch so we can use env-scoped secrets
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get frontend version
        id: frontend-version
        run: |
          VERSION=$(cat apps/hindsight-dashboard/package.json | jq -r '.version')
          echo "FRONTEND_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set build timestamp
        id: build-timestamp
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "BUILD_TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV

      - name: Build and push Hindsight Dashboard Docker image
        id: build-push-dashboard
        uses: docker/build-push-action@v5
        with:
          context: apps/hindsight-dashboard
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/hindsight-dashboard:${{ github.sha }}
            ${{ github.ref == 'refs/heads/main' && format('ghcr.io/{0}/hindsight-dashboard:latest', github.repository_owner) || '' }}
            ${{ github.ref == 'refs/heads/staging' && format('ghcr.io/{0}/hindsight-dashboard:staging-latest', github.repository_owner) || '' }}
          file: apps/hindsight-dashboard/Dockerfile
          build-args: |
            VITE_VERSION=${{ env.FRONTEND_VERSION }}
            VITE_BUILD_SHA=${{ github.sha }}
            VITE_BUILD_TIMESTAMP=${{ env.BUILD_TIMESTAMP }}
            VITE_DASHBOARD_IMAGE_TAG=ghcr.io/${{ github.repository_owner }}/hindsight-dashboard:${{ github.sha }}

  deploy:
    needs: [build-and-push-hindsight-service, build-and-push-hindsight-dashboard]
    runs-on: ubuntu-latest
    # Run on both branches, pick the environment dynamically
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: true

    env:
      # Derived values based on selected environment
      ENV_NAME: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
      SERVER_DIR: ${{ github.ref == 'refs/heads/main' && 'hindsight-ai-production' || 'hindsight-ai-staging' }}
      COMPOSE_FILE: docker-compose.app.yml

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Copy files to remote server via scp
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "${{ env.COMPOSE_FILE }},config/,templates/,letsencrypt/,infra/,check_env.sh,.env.example"
          target: "~/${{ env.SERVER_DIR }}"

      - name: Execute deployment commands on remote server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -euo pipefail
            cd ~/${{ env.SERVER_DIR }}

            # Make validation script executable
            chmod +x check_env.sh

            # Create .env file
            echo "Creating .env file for ${{ env.ENV_NAME }}..."
            cat <<EOF > .env
            HINDSIGHT_SERVICE_IMAGE=ghcr.io/${{ github.repository_owner }}/hindsight-service:${{ github.sha }}
            HINDSIGHT_DASHBOARD_IMAGE=ghcr.io/${{ github.repository_owner }}/hindsight-dashboard:${{ github.sha }}
            DEV_MODE=false
            APP_HOST=${{ secrets.APP_HOST }}
            APP_BASE_URL=https://${{ secrets.APP_HOST }}
            TRAEFIK_DASHBOARD_HOST=${{ secrets.TRAEFIK_DASHBOARD_HOST }}
            CLOUDFLARE_DNS_EMAIL=${{ secrets.CLOUDFLARE_DNS_EMAIL }}
            CLOUDFLARE_DNS_API_TOKEN=${{ secrets.CLOUDFLARE_DNS_API_TOKEN }}
            OAUTH2_PROXY_CLIENT_ID=${{ secrets.OAUTH2_PROXY_CLIENT_ID }}
            OAUTH2_PROXY_CLIENT_SECRET=${{ secrets.OAUTH2_PROXY_CLIENT_SECRET }}
            OAUTH2_PROXY_COOKIE_SECRET='${{ secrets.OAUTH2_PROXY_COOKIE_SECRET }}'
            OAUTH2_PROXY_EMAIL_DOMAINS=${{ secrets.OAUTH2_PROXY_EMAIL_DOMAINS || '*' }}
            LLM_API_KEY=${{ secrets.LLM_API_KEY }}
            LLM_MODEL_NAME=${{ secrets.LLM_MODEL_NAME }}
            EMBEDDING_PROVIDER=${{ secrets.EMBEDDING_PROVIDER || 'ollama' }}
            OLLAMA_BASE_URL=${{ secrets.OLLAMA_BASE_URL || 'http://ollama:11434' }}
            OLLAMA_EMBEDDING_MODEL=${{ secrets.OLLAMA_EMBEDDING_MODEL || 'nomic-embed-text:v1.5' }}
            QUERY_EXPANSION_ENABLED=${{ secrets.QUERY_EXPANSION_ENABLED || 'true' }}
            QUERY_EXPANSION_STEMMING_ENABLED=${{ secrets.QUERY_EXPANSION_STEMMING_ENABLED || 'true' }}
            QUERY_EXPANSION_SYNONYMS_ENABLED=${{ secrets.QUERY_EXPANSION_SYNONYMS_ENABLED || 'true' }}
            QUERY_EXPANSION_MAX_VARIANTS=${{ secrets.QUERY_EXPANSION_MAX_VARIANTS || '5' }}
            QUERY_EXPANSION_LLM_PROVIDER=${{ secrets.QUERY_EXPANSION_LLM_PROVIDER || 'ollama' }}
            QUERY_EXPANSION_LLM_MODEL=${{ secrets.QUERY_EXPANSION_LLM_MODEL || 'llama3.2:1b' }}
            QUERY_EXPANSION_LLM_MAX_VARIANTS=${{ secrets.QUERY_EXPANSION_LLM_MAX_VARIANTS || '2' }}
            QUERY_EXPANSION_OLLAMA_BASE_URL=${{ secrets.QUERY_EXPANSION_OLLAMA_BASE_URL || secrets.OLLAMA_BASE_URL || 'http://ollama:11434' }}
            QUERY_EXPANSION_LLM_TEMPERATURE=${{ secrets.QUERY_EXPANSION_LLM_TEMPERATURE || '0.0' }}
            QUERY_EXPANSION_LLM_MAX_TOKENS=${{ secrets.QUERY_EXPANSION_LLM_MAX_TOKENS || '64' }}
            QUERY_EXPANSION_LLM_TIMEOUT_SECONDS=${{ secrets.QUERY_EXPANSION_LLM_TIMEOUT_SECONDS || '5' }}
            KNOWLEDGE_BASES_ROOT_DIR=${{ secrets.KNOWLEDGE_BASES_ROOT_DIR || './knowledge_bases' }}
            CONSOLIDATION_BATCH_SIZE=${{ secrets.CONSOLIDATION_BATCH_SIZE }}
            FALLBACK_SIMILARITY_THRESHOLD=${{ secrets.FALLBACK_SIMILARITY_THRESHOLD }}
            SUPPORT_EMAIL=${{ secrets.SUPPORT_EMAIL }}
            SUPPORT_CONTACT_MIN_INTERVAL_SECONDS=${{ secrets.SUPPORT_CONTACT_MIN_INTERVAL_SECONDS }}
            PRUNING_BATCH_SIZE=${{ secrets.PRUNING_BATCH_SIZE }}
            PRUNING_MAX_ITERATIONS=${{ secrets.PRUNING_MAX_ITERATIONS }}
            EMAIL_PROVIDER=${{ secrets.EMAIL_PROVIDER }}
            FROM_EMAIL=${{ toJSON(secrets.FROM_EMAIL) }}
            FROM_NAME=${{ toJSON(secrets.FROM_NAME) }}
            REPLY_TO_EMAIL=${{ toJSON(secrets.REPLY_TO_EMAIL) }}
            RESEND_API_KEY=${{ secrets.RESEND_API_KEY }}
            EMAIL_TEMPLATE_DIR=${{ secrets.EMAIL_TEMPLATE_DIR }}
            EMAIL_RATE_LIMIT_HOUR=${{ secrets.EMAIL_RATE_LIMIT_HOUR }}
            EMAIL_RATE_LIMIT_DAY=${{ secrets.EMAIL_RATE_LIMIT_DAY }}
            ADMIN_EMAILS='${{ secrets.ADMIN_EMAILS }}'
            BETA_ACCESS_ADMINS='${{ secrets.BETA_ACCESS_ADMINS }}'
            LLM_FEATURES_ENABLED=${{ secrets.LLM_FEATURES_ENABLED || 'true' }}
            FEATURE_CONSOLIDATION_ENABLED=${{ secrets.FEATURE_CONSOLIDATION_ENABLED || 'true' }}
            FEATURE_PRUNING_ENABLED=${{ secrets.FEATURE_PRUNING_ENABLED || 'true' }}
            FEATURE_ARCHIVED_ENABLED=${{ secrets.FEATURE_ARCHIVED_ENABLED || 'true' }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
            HINDSIGHT_SERVICE_API_URL=${{ secrets.API_URL }}
            VITE_INVITATIONS_REFRESH_MS=${{ secrets.VITE_INVITATIONS_REFRESH_MS }}
            REACT_APP_HINDSIGHT_SERVICE_API_URL=https://${{ secrets.REACT_APP_HINDSIGHT_SERVICE_API_URL }}
            BACKEND_BUILD_SHA=${{ github.sha }}
            FRONTEND_BUILD_SHA=${{ github.sha }}
            BUILD_TIMESTAMP=${{ env.BUILD_TIMESTAMP }}
            BACKEND_IMAGE_TAG=ghcr.io/${{ github.repository_owner }}/hindsight-service:${{ github.sha }}
            FRONTEND_IMAGE_TAG=ghcr.io/${{ github.repository_owner }}/hindsight-dashboard:${{ github.sha }}
            EOF

            # Create authorized_emails.txt
            echo "Creating authorized_emails.txt for ${{ env.ENV_NAME }}..."
            echo "${{ secrets.AUTHORIZED_EMAILS_CONTENT }}" > authorized_emails.txt

            # Replace email placeholder in Traefik config (use the same secret name in both envs)
            echo "Replacing email placeholder in Traefik config..."
            sed -i 's/<email_placeholder>/${{ secrets.ACME_EMAIL }}/g' ./config/traefik.yml

            # Conditionally recreate acme.json for Let's Encrypt
            if [ "${{ github.event.inputs.recreate_acme_json }}" = "true" ]; then
              echo "Recreating acme.json for ${{ env.ENV_NAME }}..."
              mkdir -p ./letsencrypt
              rm -f ./letsencrypt/acme.json
              touch ./letsencrypt/acme.json
              chmod 600 ./letsencrypt/acme.json
            else
              echo "Skipping acme.json recreation for ${{ env.ENV_NAME }}."
            fi

            # Authenticate with GitHub Container Registry
            echo "Authenticating with GitHub Container Registry..."
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Validate environment variables before deployment
            echo "Validating environment variables..."
            export DEPLOYMENT_ENV="${{ env.ENV_NAME }}"
            if ! bash check_env.sh; then
              echo "‚ùå Environment validation failed! Deployment aborted."
              exit 1
            fi

            # Decide profile flag for production only
            PROFILE_FLAG=""
            if [ "${{ env.ENV_NAME }}" = "production" ]; then
              PROFILE_FLAG="--profile prod"
            fi

            # Trim unused Docker resources while services continue running
            echo "Pruning unused Docker resources before shutdown..."
            docker system prune -af

            # Pull new images and deploy
            echo "Pulling new images and deploying to ${{ env.ENV_NAME }}..."
            docker compose -f ${{ env.COMPOSE_FILE }} pull || true
            docker compose -f ${{ env.COMPOSE_FILE }} ${PROFILE_FLAG} up -d --force-recreate

            # Ensure Ollama models used for embeddings/query expansion are present
            set -a
            source .env
            set +a
            OLLAMA_MODELS=""
            if [ "${EMBEDDING_PROVIDER:-}" = "ollama" ] && [ -n "${OLLAMA_EMBEDDING_MODEL:-}" ]; then
              OLLAMA_MODELS="$OLLAMA_MODELS ${OLLAMA_EMBEDDING_MODEL}"
            fi
            if [ "${QUERY_EXPANSION_LLM_PROVIDER:-}" = "ollama" ] && [ -n "${QUERY_EXPANSION_LLM_MODEL:-}" ]; then
              OLLAMA_MODELS="$OLLAMA_MODELS ${QUERY_EXPANSION_LLM_MODEL}"
            fi
            OLLAMA_MODELS=$(echo "$OLLAMA_MODELS" | tr ' ' '\n' | sed '/^$/d' | awk '!seen[$0]++')
            if [ -n "$OLLAMA_MODELS" ]; then
              echo "Ensuring Ollama models are available..."
              attempts=0
              until docker compose -f ${{ env.COMPOSE_FILE }} exec -T ollama ollama --version >/dev/null 2>&1; do
                attempts=$((attempts + 1))
                if [ $attempts -ge 20 ]; then
                  echo "Ollama service did not become ready in time; aborting."
                  exit 1
                fi
                sleep 2
              done
              for model in $OLLAMA_MODELS; do
                echo "Ensuring Ollama model '$model' is available..."
                if ! docker compose -f ${{ env.COMPOSE_FILE }} exec -T ollama ollama pull "$model"; then
                  echo "Ollama pull failed for '$model'. Aborting deployment."
                  exit 1
                fi
              done
            fi

            # Smoke-test embedding model availability
            if [ "${EMBEDDING_PROVIDER:-}" = "ollama" ] && [ -n "${OLLAMA_EMBEDDING_MODEL:-}" ]; then
              echo "Validating Ollama embedding model '${OLLAMA_EMBEDDING_MODEL}'..."
              EMBED_PAYLOAD=$(printf '{"model":"%s","input":"deployment smoke test"}' "${OLLAMA_EMBEDDING_MODEL}")
              if ! docker compose -f ${{ env.COMPOSE_FILE }} exec -T -e PAYLOAD="$EMBED_PAYLOAD" ollama sh -c 'printf "%s" "$PAYLOAD" | curl -sfS -X POST http://localhost:11434/api/embed -d @- >/tmp/embed-check.json'; then
                echo "Embedding model validation request failed. Aborting deployment."
                exit 1
              fi
              if ! docker compose -f ${{ env.COMPOSE_FILE }} exec -T ollama sh -c 'grep -q "\"embeddings\"" /tmp/embed-check.json && rm /tmp/embed-check.json'; then
                echo "Embedding model validation response missing embeddings payload. Aborting deployment."
                exit 1
              fi
            fi

            # Smoke-test query expansion LLM availability
            if [ "${QUERY_EXPANSION_LLM_PROVIDER:-}" = "ollama" ] && [ -n "${QUERY_EXPANSION_LLM_MODEL:-}" ]; then
              echo "Validating Ollama query-expansion model '${QUERY_EXPANSION_LLM_MODEL}'..."
              QE_PAYLOAD=$(printf '{"model":"%s","prompt":"Say READY","stream":false}' "${QUERY_EXPANSION_LLM_MODEL}")
              if ! docker compose -f ${{ env.COMPOSE_FILE }} exec -T -e PAYLOAD="$QE_PAYLOAD" ollama sh -c 'printf "%s" "$PAYLOAD" | curl -sfS -X POST http://localhost:11434/api/generate -d @- >/tmp/ollama-qe-check.json'; then
                echo "Query expansion LLM validation request failed. Aborting deployment."
                exit 1
              fi
              if ! docker compose -f ${{ env.COMPOSE_FILE }} exec -T ollama sh -c 'grep -q "READY" /tmp/ollama-qe-check.json && rm /tmp/ollama-qe-check.json'; then
                echo "Query expansion LLM validation response unexpected. Aborting deployment."
                exit 1
              fi
            fi

            # Simple health check: wait 10 seconds and verify containers are still running
            echo "Performing simple health check - waiting 10 seconds..."
            sleep 10

            # Check if key containers are still running
            if docker compose -f ${{ env.COMPOSE_FILE }} ps | grep -E "(hindsight-service|hindsight-dashboard|traefik|oauth2-proxy)" | grep -q "Up"; then
              echo "‚úÖ All ${{ env.ENV_NAME }} containers are running and stable"
              echo "üéâ Deployment successful!"
            else
              echo "‚ùå Some ${{ env.ENV_NAME }} containers crashed or stopped"
              echo "Container status:"
              docker compose -f ${{ env.COMPOSE_FILE }} ps
              echo "Recent logs:"
              docker compose -f ${{ env.COMPOSE_FILE }} logs --tail 20
              exit 1
            fi
